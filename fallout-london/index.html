<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Joric's Fallout London</title>
<meta name="viewport" content="initial-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta property="og:image" content="https://i.imgur.com/6XIQcPx.jpeg" />
<meta property="og:site_name" content="Joric" />
<meta property="og:type" content="object" />
<meta property="og:title" content="Joric's Fallout London" />
<meta property="og:description" content="Interactive Map" />
<link rel="icon" href="data:,">
<link rel="search" type="application/opensearchdescription+xml" href="https://joric.github.io/maps/fallout-london/opensearch.xml" title="Joric's Fallout London" />
<link rel="stylesheet" href="main.css">

<!--
<link rel="stylesheet" href="https://unpkg.com/maptalks/dist/maptalks.css">
<script type="text/javascript" src="https://unpkg.com/maptalks/dist/maptalks.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/js/all.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>
-->

<link href="maptalks.css" rel="stylesheet">
<script src="maptalks-custom.min.js#issue-2354"></script>
<script src="all.min.js"></script>
<script src="fuse.js"></script>

<style>
html, body{margin:0px;height:100%;width:100%;font-family:sans-serif;}
.container{width:100%;height:100%}
</style>

</head>
<body>
<div tabindex=0 id="map" class="container"></div>

<div id="left-sidebar" class="sidebar">
  <div class="sidebar-close" onclick="toggleNav(this)"><div class="container middle"><i class="triangle"></i></div></div>
  <div class="panel" id="left-panel">
    <div class="caption">
      <h2>Fallout London</h2>
      <hr/>
    </div>

    <div class="map-switcher-panel">
      <a href="#LondonWorld" class="map-link">London</a>
    </div>

    <hr/>
    <div class="button-panel"><span id="show-all" onclick="showAll()">Show All</span><span id="hide-all" onclick="hideAll()">Hide All</span></div>

    <hr/>

    <form id="search-form">
      <div class="search-input-wrapper input-group">
        <button id="search-close" type="button" class="btn collapsed">x</button>
        <input id="search-input" class="form-control" type="text" placeholder="Search for anything..." autofocus/>
        <div class="input-group-append">
          <input type="submit" id="search-submit" type="button" class="btn" value="Search" />
        </div>
      </div>
    </form>

    <div id="search-result" class="collapsed group-categories">
      <div id="search-count"></div>
      <div id="search-items">
      </div>
    </div>

    <div id="categories-wrapper">
      <ul id="categories">
      </ul>

    <hr/>
    <a href="https://github.com/joric/maps/wiki/Fallout-London" class="link" target=_blank><span class="fa-brands fa-wikipedia-w"></span> About the Map</a>

    </div>

  </div>
</div>

<div id="right-sidebar" class="sidebar">
  <div class="sidebar-close" onclick="toggleNav(this)"><div class="container middle"><i class="triangle"></i></div></div>
  <div class="panel">
    <h2 id="title2">Progress Tracker</h2>
    <hr/>
      <span id="toggle-found" class="button-toggle"><i class="icon fa fa-eye"></i>Found Locations</span>
    <hr/>

    <div id="user-panel">
      <div class="category-progress">
      </div>

      <div class="button-panel" id="track-category-button">
        <span id="track-category" onclick="closeTrack()">Track Category +</span>
      </div>

      <div id="track-category-panel" class="button-panel collapsed">
        <select id="track-categories" class="form-control"><option>Select a Category</option></select>
        <div class="button-group">
          <button class="btn" onclick="addTrack(this)">Track Category</button>
          <button class="btn" onclick="toggleVisibility(['#track-category-panel','#track-category-button'])">x</button>
        </div>
      </div>

      <hr/>

      <div class="button-panel">
        <input id="file" type='file' hidden/>
        <button onclick="loadLocalData()" class="btn-link">Load</button>
        <button onclick="saveLocalData()" class="btn-link">Save</button>
        <button onclick="resetLocalData()" class="btn-link">Reset All</button>
        <!--button onclick="openLoadFileDialog()" class="btn-link" disabled title="not implemented yet">Load Game</button-->
      </div>

    </div>

  </div>
</div>

<div id="topbar" class="sidebar">
<div class="top-panel">
  <div class="mobile-container">
    <div class="mobile-title">
      <h2>Fallout London</h2>
    </div>
    <div>
      <button class="topbar-btn" id="toggle-left">Navigation</button>
      <button class="topbar-btn" id="toggle-right">Progress</button>
    </div>
  </div>
</div>
</div>

<div id="alert" class="closed">Copied To Clipboard</div>

<div id="popup" class="popup">
  <div class="popup-content-wrapper">
    <div class="popup-content">
      <div id="popup-title">Popup Title</div>
      <div id="popup-subtitle">Popup Subtitle</div>
      <div id="popup-note">Popup Note</div>
      <div id="popup-subnote" class="collapsed">Popup Subnote</div>
      <div id="popup-data" class="collapsed"></div>
      <div id="popup-data-toggle" data-toggle="collapse" data-target="popup-data"><hr/></div>
      <div class="popup-controls">
        <input id="popup-found" type="checkbox">
        <label for="popup-found" title="Toggle found">Found</label>
        <a class="popup-link" id="popup-wiki-link" href="#" target="_blank" title="Fallout London Wiki"><i class="fa fa-brands fa-wikipedia-w"></i></a>
        <a class="popup-link" id="popup-map-link" href="#" target="_blank" title="Copy Map Link to Clipboard"><i class="fa fa-link"></i></a>
        <a class="popup-link" id="popup-form-id-link" href="#" target="_blank" title="Copy Form ID to Clipboard"><i class="fa fa-hashtag"></i></a>
        <a class="popup-link" id="popup-marker-id-link" href="#" target="_blank" title="Copy Reference ID to Clipboard"><i class="fa fa-location-crosshairs"></i></a>
      </div>
    </div>
  </div>
  <div class="popup-tip-container"><div class="popup-tip"></div></div>
  <a id="popup-close" class="popup-close-button">&times;</a>
</div>

</body>
</html>

<script>
let localDataName = 'joricsFalloutLondonMaps';
let localData = JSON.parse(localStorage.getItem(localDataName)) || {};

let startPitch = 0;
let startZoom = 2;
let heightFactor = 0.5;
let defaultPitch = 45;
let enableAltitude = true;
let autoAltitude = true;
let drawMarkerAltitude = true;
let drawCurveAltitude = false;
let drawShadow = false;
let iconSize = 48;
let lineWidth = 3;
let lineDasharray = null;
let arrowStyle = [2,3];
let markerLayer = null;
let mapCenter = null;
let markerSymbol = markerSymbol2;
let map = null;
let parsed = {};
let objectNames = {};

let settings;
let counters = {};
let areas = {};
let mapBounds = [];
let types = {};
let mapId = 'LondonWorld';
let pressed = {};
let markers = {};
let mapParam = {};
let firstRun = false;
let layerName = 'markers';

let wikiPrefix = 'https://fallout.wiki/wiki/Mod:Fallout_London/';

let maps = {
  'LondonWorld' : { name: 'London', scale: 1, offset: {x:0, y:0},
    regions: {
      // regions must be precisely tuned. some are rotated
      'WestminsterWorld' : { scale: 0.6, offset: {x:-104300, y:27900}, rotation: 0.57 },
      'CamdenWorld': { scale: 1, offset: {x:-79000, y:74000}, rotation: 0 },
      'IslingtonWorld': { scale: 0.95, offset: {x:-26600, y:66500}, rotation: 0.57 },
      'HackneyWorld': { scale: 0.95, offset: {x:19100, y:44000}, rotation: 0.78 },
      'BankofEnglandWorld': { scale: 1, offset: {x:-32000, y:35500} },
      'BromleyGladesWorld': { scale: 1, offset: {x:0, y:0} },
      'StPaulsWorld': { scale: 1, offset: {x:3000, y:0} },
      'CoventGardenWorldSpace': { scale: 1, offset: {x:1500, y:-2000} },

      // those seem to be pretty close to worldspace offsets (try zero values)
      'IWMWorld':{ scale: 1, offset: {x:0, y:0} },
      'DumpWorld':{ scale: 1, offset: {x: 2000, y: -2000,} },
      'BromleyPindarWorld':{ scale: 1, offset: {x:-9000, y:-8000} },
    },
  },
  // individual maps, must be somewhere in the game data. they are never rotated.
  'WestminsterWorld' : { name: 'Westminster', scale: 1.9, offset: {x:7000, y:22000} },
  'IslingtonWorld': { name: 'Islington', scale: 3.82, offset: {x:0, y:-47500} },
  'HackneyWorld' : { name: 'Hackney', scale: 3.77, offset: {x:-77500, y:-63000} },
  'CamdenWorld': { name: 'Camden', scale: 3.77, offset: {x:15000, y:-126000} },
  'BankofEnglandWorld': { name:'Bank of England', scale: 3.77, offset: {x:6000, y:4800} },

  // some maps are hidden so offset doesn't matter here
  'CoventGardenWorldSpace': { name:'Covent Garden', scale: 1, offset: {x:0, y:0}, hidden: true },
  'BromleyGladesWorld': { name: 'Bromley Glades', scale: 1, offset: {x:0, y:0}, hidden: true },
  'StPaulsWorld': { name: 'St Pauls', scale: 1, offset: {x:0, y:0}, hidden: true },
  'IWMWorld':{ name: "War Museum", scale: 1, offset: {x:0, y:0}, hidden: true },
  'DumpWorld': { name: 'Dump', scale: 1, offset: {x:0, y:0}, hidden: true },
  'BromleyPindarWorld': { name: 'Bromley Pindar', scale: 1, offset: {x:0, y:0}, hidden: true },
};

let cells = {
  '07254631': {name: 'Westminster Underground', scale: 0, offset: {x: 0, y:0} },
}

function closeTrack(){
  toggleVisibility(['#track-category-panel','#track-category-button']);
}

function addTrack(e) {
  let sel = document.querySelector('#track-category-panel > select');
  if (value = sel[sel.selectedIndex].value) {
    settings.track[value] = true;
    saveSettings();
    markItems();
    closeTrack();
  }
}

function unmarkItems() {
  settings.markedItems={};
  markItems();
}

function resetLocalData() {
  if (confirm('Are you sure you want to reset settings?')) {
    localStorage.removeItem(localDataName);
    location.reload();
  }
}

function loadLocalDataFile() {
  var file = document.querySelector("#file").files[0];
  if (file) {
    var reader = new FileReader();
    reader.readAsText(file, "UTF-8");
    reader.onload = function (evt) {
      let data = evt.target.result;
      evt.target.value = null;
      try {
        localData = JSON.parse(data);
        settings = localData[mapId];
        console.log('New settings loaded.');
        saveSettings();
        markItems();
      } catch(e) {
        console.log(e);
      }
    }
    reader.onerror = function (evt) {
      alert('error reading file');
    }
  }
}

function loadLocalData() {
  document.querySelector('#file').onchange = function(e) {
    loadLocalDataFile();
  }
  document.querySelector('#file').value = null;
  document.querySelector('#file').accept = '.json';
  document.querySelector('#file').click();
}

function saveLocalData() {
  let data = localStorage.getItem(localDataName);
  if (window.showSaveFilePicker) {
    window.showSaveFilePicker({suggestedName: localDataName+'.json'}).then(f=>f.createWritable()).then(f=>f.write(data).then(()=>f.close()));
  } else {
    let filename = localDataName+'.json';
    let blob = new Blob([data], {type: "text/json"});
    if(navigator.msSaveOrOpenBlob) {
        navigator.msSaveOrOpenBlob(blob, filename);
    } else {
        var a = document.body.appendChild(document.createElement("a"));
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        a.remove();
    }
  }
}

function unmarkAll() {
  if (confirm('Are you sure you want to unmark all items?')) {
    unmarkItems();
    saveSettings();
  }
}

function createMap() {
  // fill map switcher panel
  let div = document.querySelector('.map-switcher-panel');
  div.replaceChildren();

  for (const [id,m] of Object.entries(maps)) {
    if (m.hidden) continue;
    let a = document.createElement('a');
    a.innerText = m.name;
    a.className = 'map-link';
    a.href = '#' + id;
    a.onclick = function(e){ loadMap(e.target.href.split('#').pop()); return false; }
    div.appendChild(a);
    if (mapId==id) {
      a.classList.add('selected');
    }
  }

  let cw = ch = 4096;
  let w = h = 64;

  let mapSize = {width: 2048, height: 2048}

  let mapWorldSize = w * cw;
  let scale = mapWorldSize / mapSize.width;

  let mapWorldCenter = { X: 0.0, Y: 0.0, Z: 0.0 };
  let mapWorldUpperLeft = { X: -w*cw/2, Y: -h*ch/2, Z: 0.0 };
  let mapWorldLowerRight = { X: w*cw/2, Y: h*ch/2, Z: 0.0 };

  mapCenter = [mapWorldCenter.X, mapWorldCenter.Y];
  mapBounds = [mapWorldUpperLeft.X, mapWorldUpperLeft.Y, mapWorldLowerRight.X, mapWorldLowerRight.Y];

  let [left,top,right,bottom] = mapBounds;
  let extent = new maptalks.Extent(left, top, right, bottom);

  if (!settings.center) {
    [settings.zoom, settings.pitch, settings.bearing, settings.center] = [startZoom, startPitch, 0, mapCenter];
  }

  map = new maptalks.Map('map', {
    heightFactor: heightFactor,
    zoom: settings.zoom,
    pitch: settings.pitch,
    bearing: settings.bearing,
    center: settings.center,
    maxExtent: extent,
    maxPitch: 80,
    spatialReference : {
      projection : 'identity',
      resolutions: [8,4,2,1,1/2,1/4,1/8,1/16,1/32,1/64,1/128].map(x=>x*scale),
      fullExtent : { top: top, left: left, bottom: bottom, right: right },
    },
    baseLayer: new maptalks.TileLayer('base', {
      maxAvailableZoom: 2,
      urlTemplate: 'tiles/'+mapId+'/{z}/{x}/{y}.png',
      repeatWorld: false,
      tileSystem: [ 1, -1, left, top ],
    }),
    seamlessZoom: true,
    doubleClickZoom: true,

    zoomControl: {
      //position  : 'bottom-right',
      //position  : 'top-right',
      position  : {bottom: 70, right: 20},
      zoomLevel : false,
    },

    attribution: {
      content: '', position: {top: -50, left: 0},
    },

  });

  markerLayer = new maptalks.VectorLayer('markers', {
    enableAltitude: enableAltitude,
    sortByDistanceToCamera: true,
    forceRenderOnMoving: true,
    forceRenderOnRotating: true,
  }).addTo(map);

  if (drawMarkerAltitude) {
    markerLayer.setOptions({drawAltitude : {lineWidth : lineWidth, lineColor : '#fff', lineOpacity: 0.25, lineDasharray: lineDasharray }});
  }

  map.on('viewchange', e=> {
    settings.center = [e.new.center[0],e.new.center[1]];
    settings.bearing = e.new.bearing;
    settings.pitch = e.new.pitch;
    settings.zoom = e.new.zoom;

    if (enableAltitude && autoAltitude) {
      markerLayer.setOptions({enableAltitude: map.getPitch()!=0});
    }
    saveSettings();

  });

  let compassControl = new maptalks.control.Compass({position  : 'bottom-right'}).addTo(map)
    ._compass.onclick = (e)=>map.getBearing()==0 && map.animateTo({ pitch: map.getPitch()==0 ? defaultPitch : 0 })

  map.on('click', function(e) {
    document.getElementById('map').focus(); // needs tabindex
  });
}


function itemText(text, o, noindex=true) {
  let t = getType(o);
  for (let [reg, rep] of Object.entries(t.replace||{})) {
    if (noindex && rep.includes('{index}')) return text;
    let index = o.editor_id.match(/^.*(\d\d)$/);
    if (index) rep = rep.replace('{index}', parseInt(index[1]));
    text = text.replace(new RegExp(reg,'g'), rep);
  }
  return text.trim();
}

function itemName(o) {
  return itemText( o.door_name || o.title || 'Unnamed', o, false);
}

function getType(o) {
  let defaults = { bg: 'grey', fg: 'white', fa: 'circle-question', group:'misc'};
  t = {...defaults, type: o.description, group_weight:0, ...(types[o.description] || {})};
  for (const [key, tt] of Object.entries(t.items||{})) {
    if (tt.match || tt.cell) {
      if ( (tt.match && (o.editor_id||o.title).match(new RegExp(tt.match,'g'))) || (tt.cell && o.cell) ) {
        t = {...t, ...tt, key: key};
        if (!tt.type) {
          t = {...t, subtype: key};
        }
        return t;
      }
    }
  }
  return t;
}

function markerSymbol2(o) {
  let d = 48;
  let t = getType(o);
  let icon = t.fa;
  let bg = t.bg;
  let fg = t.fg;

  let [w1,h1,[s1],c1,p1] = FontAwesome.icon({ iconName: 'location-pin' }).icon;

  // mark all persons with quests
  if (icon=='person' && !o.quests ) {
    icon = 'person-walking';
  }

  // mark non-teleport doors
  if ((icon=='door-open') && o.keys) {
    icon='door-closed';
  }


  if (!(fa = FontAwesome.icon({ iconName: icon }))) {
    fa = FontAwesome.icon({ icon: 'circle-question' });
  }

  let [w2,h2,[s2],c2,p2] = fa.icon;

  let k = 0.45;

  let dx = (w1-w2*k)/2;
  let dy = (h1-h2*k)/2 - h1*0.125;

  let path = [
    {path:p1, fill: 'black'},
    {transform: 'matrix(0.976,0,0,0.976,5,5)', path: p1, fill: bg },
    {transform: 'matrix('+k+',0,0,'+k+','+dx+','+dy+')', path:p2, fill: fg }
  ];
  return {
    markerType: 'path',
    markerPath : path,
    markerPathWidth : w1,
    markerPathHeight : h1,
    markerLineColor : 12,

    markerWidth: w1*d/512,
    markerHeight: h1*d/512,

    //markerWidth: { stops:[] }, // { stops: [[1, 16], [5, 32], [7, 64]] },

    markerDy : 0,
    markerDx : 0
  };
}

function saveSettings() {
  localStorage.setItem(localDataName, JSON.stringify(localData));
}

function showAll(e) {
  updateAll(e, true);
}

function hideAll(e) {
  updateAll(e, false);
}

function updateAll(e, show=true, type=null) {
  lookup = {};

  if (type) {
    let div = e.target;
    lookup[type] = div;
    show ? setClass(div, false, 'hidden') : setClass(div, true, 'hidden');
  } else {
    for (div of document.querySelectorAll('.category')) {
      lookup[div.alt] = div;
      show ? setClass(div, false, 'hidden') : setClass(div, true, 'hidden');
    }
  }

  return false;
}

function toggleItem(e) {
  e.preventDefault();
  return updateAll(e, e.target.classList.contains('hidden'), e.target.alt);
}

function setClass(e, set, c) { set ? e.classList.add(c) : e.classList.remove(c);}
function toggleClass(e, c) { if (e.classList.contains(c)) { e.classList.remove(c); return false; } else { e.classList.add(c); return true; }}
function toggleNav(e) { let input = document.querySelector('#search-input'); toggleClass(e.parentElement, 'closed') ? input.blur() : input.focus();}
function toggleVisibility(a) { [].forEach.call(a, function(e) { toggleClass(document.querySelector(e), 'collapsed'); }) }
const cmpNum = (a,b)=> b[1]!=a[1] ? (b[1]-a[1]) : a[0].localeCompare(b[0]);
const cmpAlphaNum = (a,b) => a[0].localeCompare(b[0], 'en', { numeric: true });
const capitalize = s => s[0].toUpperCase()+s.slice(1);

function itemArea(o) {
  if (o.area) return o.area;
  let path = exits[o.cell];
  if (path && path.length>0) {
    //console.log(path, 'last door', path[path.length-1]);
    return path[path.length-1].properties.area;
  }
}

let itemLocation = o => ((area = itemArea(o)) && (maps[area] && maps[area].name) || area) + ( (cell = (o.cell && o.cell_name)) ? ' (' + cell + ')' : '');
let itemDescription = o=> itemName(o) + ' (' + itemTypeExtended(o) + ')';
let itemType = o => getType(o).type;
let itemTypeExtended = o => {t = getType(o); return t.subtype ? t.type + ' / ' + t.subtype : t.type; } 
let human = s=>s.replace(/([A-Z]+|[\d]+)/g, ' $1').replace(/^ /, ''); // camel case to space-separated
let plural = (x,s)=> x + ' ' +(x>1 ? (s.endsWith('y') ? s.slice(0,-1)+'ies':s+'s') : s);

function showAll(e) { toggleItems(e, true, document.querySelectorAll('#categories .category-item')); }
function hideAll(e) { toggleItems(e, false, document.querySelectorAll('#categories .category-item')); }

function toggleItem(e) {
  e.preventDefault();
  return e.target.alt && toggleItems(e, e.target.classList.contains('hidden'), [e.target]);
}

function toggleGroup(e) {
  e.preventDefault();
  // check siblings, if not all visible set show to false else true
  let show = true;
  let divs = e.target.nextSibling.querySelectorAll('.category-item');
  [].forEach.call(divs,function(e) {
    if (!e.classList.contains('hidden')) show = false;
  });
  return e.target.alt && toggleItems(e, show, divs);
}

function toggleItems(e, show, parent) {
  ids = {};
  for (div of parent) {
    ids[div.alt] = true;
  }

  for (marker of markerLayer._geoList) {
    let o = marker.properties;
    let t = getType(o);
    if (!ids[t.type]) continue;
    if (show) {
      settings.activeItems[t.type] = true;
    } else {
      delete settings.activeItems[t.type];
    }
  }

  saveSettings();
  markItems();

  return false;
}


function markItems() {

  // update markers
  for (marker of markerLayer._geoList) {
    let o = marker.properties;
    let t = getType(o);
    marker.updateSymbol({markerOpacity: settings.markedItems[o.ref_id] ? 0.25 : 1 });
    let hide = !settings.activeItems[t.type];
    if (settings.hideFound && settings.markedItems[o.ref_id]) hide = true;
    hide ? marker.hide() : marker.show();
  }

  [].forEach.call(document.querySelectorAll('#categories .header'), function(header) {
    let groupShow = false;
    let divs = header.nextSibling.querySelectorAll('.category-item');
    [].forEach.call(divs,function(div) {
      if (settings.activeItems[div.alt]==true) {
        div.classList.remove('hidden');
        groupShow = true;
      } else {
        div.classList.add('hidden');
      }
    });
    setClass(header, !groupShow, 'hidden');
  });

  updateTracking();
}

function toggleTrack(e) {
  e.preventDefault();
  let id = e.target.alt;
  //settings.track[id] = !settings.track[id];
  saveSettings();
  return toggleItems(e, e.target.classList.contains('hidden'), [e.target]);
}

function updateTracking() {
  let total = {};
  let marked = {};
  let cached_types = {};

  for (marker of markerLayer._geoList) {
    let o = marker.properties;
    let t = getType(o);
    let found = settings.markedItems[o.ref_id];
    total[t.type] = (total[t.type] || 0) + 1;
    marked[t.type] = (marked[t.type] || 0) + (found ? 1 : 0);
    cached_types[t.type] = {...cached_types[t.type], ...t};
  }

  let base = document.querySelector('.category-progress');
  base.innerHTML = '';

  for (type of Object.keys(settings.track).sort(cmpAlphaNum)) {
    let t = cached_types[type];
    if (!t) continue;

    let div = document.createElement('div');
    div.className = 'progress-item-wrapper';
    base.append(div);

    let li = document.createElement('div');
    li.className = 'item';
    li.classList.add('progress-item');
    li.alt = t.type;
    li.title = t.type;
    li.onclick = toggleTrack;

    if (settings.activeItems[type]!=true) {
      li.classList.add('hidden');
    }

    let c0 = document.createElement('span');
    c0.className = 'icon';
    c0.classList.add('fa');
    c0.classList.add('fa-'+(t.group_fa || t.fa));

    let c1 = document.createElement('span');
    c1.className = 'title';
    c1.innerHTML = t.type;

    let c2 = document.createElement('span');
    c2.className = 'counter';
    c2.innerHTML = (marked[t.type] || 0) + '/' + (total[t.type] || 0);

    let c3 = document.createElement('div');
    c3.className = 'progress-item-remove';
    c3.innerHTML = 'x';
    c3.alt = type;

    c3.onclick = function(e) { // removeTrack
      let type = e.target.alt;
      if (confirm('Are you sure you want to delete this category?')) {
        delete settings.track[type];
        saveSettings();
        markItems();
      }
    }

    li.appendChild(c0);
    li.appendChild(c1);
    li.appendChild(c2);
    li.appendChild(c3);
    div.appendChild(li);
  }
}

function toggleMarked(id) {
  if (settings.markedItems[id]) {
    delete settings.markedItems[id];
  } else {
    settings.markedItems[id] = true;
  }

  for (marker of markerLayer._geoList) {
    let o = marker.properties;
    if (id == o.ref_id) {
      let found = settings.markedItems[id];
      marker.updateSymbol({markerOpacity: found ? 0.25 : 1 });
      break;
    }
  }
  updateTracking();
  saveSettings();
}

function copyToClipboard(text) {
  let input = document.body.appendChild(document.createElement("input"));
  input.value = text;
  input.focus();
  input.select();
  document.execCommand('copy');
  input.parentNode.removeChild(input);
  document.getElementById('alert').classList.remove('closed');
  setTimeout(function(e){ document.getElementById('alert').classList.add('closed') },1500);
}


function canonical(id) {
  return id ? id.slice(2) : '';
}

function getBaseURL() {
  return window.location.href.replace(/#.*$/,'');
}

function getMapURL(id) {
  return getBaseURL() + '#' + encodeURIComponent(id);
}

function wikify(o) {
  let count = 0;
  for (const marker of map.getLayer('markers')._geoList) {
    let m = marker.properties;
    if (m.title == o.title) {
      count += 1;
      if (count>1) break;
    }
  }
  let location_id = count > 1 ? canonical(o.ref_id) : o.title;
  return location_id.replace(/[^A-Za-z0-9\s]/g, '').trim().replace(/\s+/g, '_');
}

let debugParam = '';//'Cigarette_Card_Wild_Animal_No39';

function findLocation(text) {
  let collection = map.getLayer('markers')._geoList;
  let split = s=>s ? s.toLowerCase().split(/[\s|_]+/):[];
  let words = split(text);
  let name = words.join(' ');

  // try exact match first
  for (let stage=0; stage<3; stage++) {
    for (marker of collection) {
      let o = marker.properties;
      let base = [o.title, o.form_id, canonical(o.form_id)].map(s=>s ? s.toLowerCase():'')
      let scramble = [...split(o.title), itemType(o), itemLocation(o)].map(s=>s?s.toLowerCase():'');
      let tags = [o.title, o.description, itemType(o), itemLocation(o)].map(s=>s ? s.toLowerCase():'');
      if (stage==0 && (canonical(o.form_id)==canonical(name) || text==wikify(o) || base.includes(name))) return marker;
      if (stage==1 && words.every(e=>scramble.includes(e))) return marker;
      if (stage==2 && words.every(e=>tags.includes(e))) return marker;
    }
  }

  if (result = fuzzySearch(text, 1, 0.25)) {
    if (debugParam) console.log('fallback to fuzzy with', text);
    return result[0].item.marker;
  }
}

function fuzzySearch(s, limit, threshold) {
  let data = [];
  let collection = map.getLayer('markers')._geoList;
  for (marker of collection) {
    let o = marker.properties;
    let items = [];
    let objectives = [];
    let fragments = [];

    for (const section of ['quests','weapons', 'perks', 'outfits', 'keys']) {
      let list = o[section];
      if (!list) continue;
      for (const id of list) {
        let name = markers[section][id].name || markers[section][id].editor_id || id;
        let desc = markers[section][id].description;
        let title = desc ? ( name +': ' + desc ) : name;
        items.push(id);
        items.push(itemText(title, o));

        if (section=='quests') {
          for (let [key,value] of Object.entries(markers[section][id].objectives||{})) {
            objectives.push(value);
          }

          for (let [key,value] of Object.entries(markers[section][id].fragments||{})) {
            // fragments.push(value); // perhaps do not search by fragments?
          }

        }

      }
    }

    data.push({...o, ...{display_name: itemDescription(o), custom_type: itemType(o), location: itemLocation(o), items: items, marker: marker, objectives:objectives, fragments:fragments}});
  }

  limit = limit || 100;
  threshold = threshold || 0.75;

  let options = {
    //keys: ['title','description','display_name','form_id','ref_id','editor_id','custom_type','location','items','objectives'],
    keys: [
      { name: 'title', weight: 0.8 },         // Higher weight for titles
      { name: 'description', weight: 0.4 },
      { name: 'display_name', weight: 0.3 },
      { name: 'form_id', weight: 0.2 },
      { name: 'ref_id', weight: 0.2 },
      { name: 'editor_id', weight: 0.2 },
      { name: 'custom_type', weight: 0.2 },
      { name: 'location', weight: 0.2 },
      { name: 'items', weight: 0.1 },           // Lower weight for items
      { name: 'objectives', weight: 0.01 },
      { name: 'fragments', weight: 0.01 },
    ],
    threshold: threshold,
    ignoreLocation: true,
    includeScore: true,
    useExtendedSearch: true, // search by words
    findAllMatches: false, // stop on perfect match
  }

  let fuse = new Fuse(data, options);
  let result = fuse.search(s, { limit: limit });

  const cmpAlphaNum2 = (a,b) => a.localeCompare(b, 'en', { numeric: true });
  result.sort( (a,b)=> a.score - b.score || cmpAlphaNum2(a.item.description, b.item.description) ) ;

  return result;
}

function jumpToLocation(name) {
  if (marker = findLocation(name)) {
    map.animateTo({center: marker.getCoordinates(), zoom:3, pitch:0, bearing:0});
    marker.show();
    popupOnClick({target: marker});
    marker.openInfoWindow();
  }
}

function popupOnClick(e) {
  let marker = e.target;
  let o = marker.properties;

  let popup = document.querySelector('#popup').cloneNode(true);
  let copyLink = e=>{ copyToClipboard(e.target.href); return false; };

  popup.querySelector('#popup-data-toggle').onclick = function() {
    let data_id = popup.querySelector('#popup-data-toggle').getAttribute('data-target');
    settings.debugMode = !toggleClass(document.querySelector('#'+data_id),'collapsed');
    saveSettings();
  };

  let div = popup.querySelector('#popup-subnote');
  div.replaceChildren();

  // go through all quests. if we have a related fragment in the inventory, add a related quest
  let added_quests = [];
  for (const [quest_id, prop] of Object.entries(markers.quests)) {
    for (const [i, section] of Object.entries(['weapons', 'perks', 'outfits', 'keys'])) {
      let list = o[section];
      if (!list) continue;
      let fragments = markers['quests'][quest_id]['fragments']||{};
      for (const form_id of list) {
        if (fragments[form_id]) {
          //console.log('related quest', quest_id);
          added_quests.push(quest_id);
        }
      }
    }
  }

  // if it's a key, go through all doors, add door to the key inventory
  markers['doors'] = {};
  let added_doors = [];
  for (marker of markerLayer._geoList) {
    let o1 = marker.properties;
    for (const key_id of (o1.keys||[])) {
      if (key_id == o.form_id) {
        //console.log('adding door', o1);
        added_doors.push(o1.ref_id);
        markers['doors'][o1.ref_id] = {
          editor_id: o1.editor_id,
          name: o1.door_name || ( o1.title == 'Door' ?  itemLocation(o1) : o1.title),
          //description: itemDescription(o1),
        }
      }
    }
  }

  for (const [i, section] of Object.entries(['quests', 'weapons', 'perks', 'outfits', 'keys', 'doors'])) {
    let list = o[section] || [];

    if (section=='quests') { list = [...list, ...added_quests]; }
    if (section=='doors')   { list = [...list, ...added_doors]; }

    list = list.filter((item, pos) => list.indexOf(item) === pos) // deduplicate
    if (list.length==0) continue;

    div.classList.remove('collapsed');
    div.appendChild(document.createElement('hr'));

    const strip = s=>s.replace( /<[^>]+>/gi, 'X');

    for (const form_id of list) {

      //if (section=='doors') console.log(form_id, markers[section], markers[section][form_id]);

      let editor_id = markers[section][form_id].editor_id || form_id;
      let name = markers[section][form_id].name || editor_id;
      let desc = markers[section][form_id].description;
      let title = desc ? ( name +': ' + desc ) : name;
      let objectives = markers[section][form_id]['objectives']||{};
      let fragments = markers[section][form_id]['fragments']||{};

      let li = document.createElement('div');
      li.className = 'popup-subnote-item';

      let c0 = document.createElement('a');
      c0.className = 'icon';

      let i0 = document.createElement('span');
      i0.classList.add('fa');
      i0.classList.add('fa-' + ['scroll','gun','star','shirt','key','door-closed',''][i]);

      c0.href = wikiPrefix + encodeURIComponent(itemText(name, o));
      //c0.onclick = function() { copyToClipboard(section=='quests' ? editor_id : form_id); return false; };
      c0.onclick = function() { if (!e.ctrlKey) { copyToClipboard(form_id); return false; } }; // click on icon copies quest id
      c0.appendChild(i0);


      let a = document.createElement('a');
      c0.title = section == 'quests' ? `Copy Quest ID to Clipboard (${form_id})` : `Copy Form ID to Clipboard (${form_id})`;

      a.title = `Click Icon to Copy ID (${form_id})`;

      if (Object.keys(objectives).length>0) {
        a.title += '\n--- objectives ---\n' + Object.entries(objectives).map( ([key,value])=>`${key}: ${strip(value)}`).join('\n');
      }

      if (Object.keys(fragments).length>0) {
        a.title += '\n--- fragments ---\n' + Object.entries(fragments).map( ([key,value])=>`${key}: ${strip(value)}`).join('\n');
      }

      a.textContent = itemText(title, o);
      a.href = wikiPrefix + encodeURIComponent(itemText(name, o));
      a.onclick = function(e) { if (!e.ctrlKey) {copyToClipboard(section=='quests' ? editor_id : form_id); return false;} };

      li.appendChild(c0);
      li.appendChild(a);
      div.appendChild(li);

      function appendIcon(parent, fa, href, onclick) {
          let c0 = document.createElement('a');
          c0.className = 'icon';
          c0.innerHTML = '&nbsp;';
          let i0 = document.createElement('span');
          i0.classList.add('fa');
          for (s of fa.split(' ')) i0.classList.add(s);
          c0.href = wikiPrefix + encodeURIComponent(itemText(name, o));
          c0.target = '_blank';
          onclick && c0.onclick;
          c0.appendChild(i0);
          parent.appendChild(c0);
      }

      let addWikiIcons = false;

      if (section != 'quests' || Object.keys(objectives).length==0) {
        addWikiIcons && appendIcon(li, 'fa-brands fa-wikipedia-w', wikiPrefix+encodeURIComponent(itemText(name,o)));

        // override title click, 
        a.onclick = function(e) {
          if (!e.ctrlKey) { 
            e.preventDefault();

            // find marker that refers to the item id
            for (marker of markerLayer._geoList) {
              let o = marker.properties;
              let t = getType(o);
              if (o.form_id == form_id || o.ref_id == form_id) {
                map.animateTo({center: marker.getCoordinates(), zoom:3, pitch:0, bearing:0});
                marker.show();
                popupOnClick({target: marker});
                marker.openInfoWindow();
                return false;
              }
            }

            copyToClipboard(form_id);
            return false;
          }
        };
      }


      if (section=='quests') {
        if (Object.keys(objectives).length>0) {

          let c = document.createElement('span');
          c.className = 'popup-subnote-toggle';
          c.setAttribute('data-toggle','collapse');
          c.setAttribute('data-target', form_id);

          c.onclick = function(e) {
            let id = e.target.getAttribute('data-target');
            toggleClass(e.target, 'open');
            toggleClass(document.getElementById(id), 'collapsed');
            return false;
          };

          // override title click
          a.onclick = function(e) { if (!e.ctrlKey) { e.preventDefault(); return c.click(); } };

          li.appendChild(c);

          addWikiIcons && appendIcon(li, 'fa-brands fa-wikipedia-w', wikiPrefix+encodeURIComponent(itemText(name,o)));

          let d = document.createElement('div');
          d.className = 'popup-subnote-info';
          d.id = form_id;
          d.classList.add('collapsed');

          for (const [key,value] of Object.entries(objectives)) {
            let e = document.createElement('div');
            e.className = 'popup-subnote-info-item';
            e.title = `Copy Quest Stage to Clipboard (${key})`;
            e.onclick = function() { copyToClipboard(key); return false; };
            e.textContent = `${key}: ${strip(value)}`;
            d.appendChild(e);
          }

          for (const [key,value] of Object.entries(fragments)) {
            let e = document.createElement('div');
            e.className = 'popup-subnote-info-item';
            e.title = `Copy Item ID to Clipboard (${key})`;
            e.onclick = function() { copyToClipboard(key); return false; };
            e.textContent = `Fragment: ${strip(value)}`;
            d.appendChild(e);
          }

          div.appendChild(d);
        }
      }

    }
  }

  popup.querySelector('#popup-title').textContent = itemName(o);
  popup.querySelector('#popup-title').title = o.form_id + (o.editor_id ? ' '+o.editor_id : '');
  popup.querySelector('#popup-subtitle').textContent = itemTypeExtended(o);
  popup.querySelector('#popup-note').textContent = itemLocation(o);

  if (o.cell) {
    popup.querySelector('#popup-note').title = `Copy Cell ID to Clipboard (${o.cell})`;
    popup.querySelector('#popup-note').onclick = function() { copyToClipboard(o.cell); };
    popup.querySelector('#popup-note').classList.add('clickable');
  } else {
    popup.querySelector('#popup-note').removeAttribute('title');
    popup.querySelector('#popup-note').onclick = null;
    popup.querySelector('#popup-note').classList.remove('clickable');
  }

  popup.querySelector('#popup-data').innerHTML = '<hr/><pre>'+JSON.stringify(o, null, 2) + '</pre>';
  popup.querySelector('#popup-found').checked = settings.markedItems[o.ref_id]==true;
  popup.querySelector('#popup-found').onclick = function() { toggleMarked(o.ref_id) };

  popup.querySelector('#popup-marker-id-link').href = '#' + o.ref_id;
  popup.querySelector('#popup-marker-id-link').onclick = function(e){ copyToClipboard(e.target.href.split('#')[1]); return false; };

  popup.querySelector('#popup-form-id-link').href = '#' + (o.form_id || '00000010');
  popup.querySelector('#popup-form-id-link').onclick = function(e){ copyToClipboard(e.target.href.split('#')[1]); return false; };

  popup.querySelector('#popup-map-link').href = getMapURL(wikify(o));
  popup.querySelector('#popup-map-link').onclick = copyLink;

  popup.querySelector('#popup-wiki-link').href = wikiPrefix+encodeURIComponent(itemName(o));
  popup.querySelector('#popup-close').onclick = function() {  e.target._infoWindow.hide(); };

  setClass(popup.querySelector('#popup-data'), settings.debugMode!=true, 'collapsed');

  e.target._infoWindow.setOptions({custom: true, dy: -12});
  e.target._infoWindow.setContent(popup);

  popup.addEventListener('contextmenu', function(e) { e.stopPropagation()}, true); // enable default context menu
}

let mouseMoved = false;
document.addEventListener('mousedown', function(event) {mouseMoved = false; });
document.addEventListener('mousemove', function(event){mouseMoved = true;});

let title_lookup = {};
let ref_lookup = {};
let cell_doors = {};
let exits = {};
//let cc = {};

function loadMarkers() {
  let counters = {};
  let counters2 = {};

  // fill lookup tables
  for (feature of markers.features) {
    let o = feature.properties;
    title_lookup[o.title] = feature;
    ref_lookup[o.ref_id] = feature;

    if (o.cell && o.other_door) {
      cell_doors[o.cell] = (cell_doors[o.cell]||[]);
      cell_doors[o.cell].push(feature);
    }

    //cc[o.cell] = o.cell_name;
  }

  function find_path(cell_id) {
    const visited = new Set();
    const queue = [[cell_id, []]];
    while (queue.length > 0) {
      const [current_cell_id, path] = queue.shift();
      if (visited.has(current_cell_id)) continue;
      visited.add(current_cell_id);
      for (const door of cell_doors[current_cell_id]||[]) {
        const next_door = ref_lookup[door.properties.other_door];
        if (next_door.properties.area) return [...path, door, next_door];
        queue.push([next_door.properties.cell, [...path, door]]);
      }
    }
  }

  // this is 2x faster
  const visited = new Set();
  function find_path_rec(cell_id, clear = true) {
    if (clear) visited.clear();
    if (visited.has(cell_id)) return null;
    visited.add(cell_id);
    let doors = cell_doors[cell_id];
    for (const door of doors||[]) {
      const next_door = ref_lookup[door.properties.other_door];
      if (!next_door || !next_door.properties) return null;
      if (next_door.properties.area) return [door, next_door]; // Return the path
      const result = find_path_rec(next_door.properties.cell, false);
      if (result) return [door, ...result]; // Append current door to the path
    }
  }

  // for each cell, find and remember exits
  for (cell_id of Object.keys(cell_doors)) {
    exits[cell_id] = find_path_rec(cell_id);
  }

  /*
  let oc = {};
  for (cell_id of Object.keys(cc)) {
    if (!find_path(cell_id)) oc[cell_id] = [cell_id, cc[cell_id], cell_doors[cell_id]];
  }
  console.log('orphaned_cells', Object.keys(oc).length, oc);
  */

  function rotate2d( x,y, angle, cx, cy ) {
    x = x - cx;
    y = y - cy;
    let tx = x * Math.cos(angle) - y * Math.sin(angle);
    let ty = x * Math.sin(angle) + y * Math.cos(angle);
    x = tx + cx;
    y = ty + cy;
    return [x,y];
  }

  function getLoc(feature) {
    let [x,y,z] = feature.geometry.coordinates;

    let o = feature.properties;

    //o._coordinates = feature.geometry.coordinates;

    let area = itemArea(o);

    if (o.cell) {
      let path = exits[o.cell];
      if (path && path.length>0) {
        o._doors = path.reduce((a,f) => ({ ...a, [f.properties.ref_id]:f.properties.area||f.properties.cell_name||f.properties.cell}), {});

        // just take two last doors and smoosh them together

        let door = path[0];

        let [dx,dy,dz] = door.geometry.coordinates;
        x = x - dx;
        y = y - dy;
        z = z - dz;

        door = path[path.length-1];
        [dx,dy,dz] = door.geometry.coordinates;

        [x,y] = rotate2d(x,y, door.properties.rotation[2]*Math.PI/180, 0,0);

        x = x + dx;
        y = y + dy;
        z = z + dz;

      }
    }

    let w = markers.worldspaces[area];

    let t = {scale: w.scale, offset:{x: w.offset[0],  y: w.offset[1], z: w.offset[2]}};

    if (t) {
      x = x * t.scale + t.offset.x;
      y = y * t.scale + t.offset.y;
    }

    if (t = (maps[mapId].regions && maps[mapId].regions[area])) {

      x = x * t.scale + t.offset.x;
      y = y * t.scale + t.offset.y;
      if (t.rotation) {
        [x,y] = rotate2d(x,y, t.rotation, t.offset.x, t.offset.y);
      }

    } else if (t = maps[area]) {

      x = x * t.scale + t.offset.x;
      y = y * t.scale + t.offset.y;
    }

    return {'x':x, 'y':-y, 'z':z};
  }

  let cached_types = {};
  let weights = {};
  let total = 0;

  for (feature of markers.features) {
    let o = feature.properties;

    if (!o.description) continue;

    let t = getType(o);
    weights[t.group] = Math.max(weights[t.group]||0, t.group_weight);

    let area = itemArea(o);
    let type = t.type;

    if (area != mapId && !(maps[mapId].regions && maps[mapId].regions[area])) continue;

    // hide dev cell
    if (o.cell_name=='C3Delight Dev Cell') continue;

    // hide 'Libertalia' (since 1.02, Folon_ACTI_BarryBoatBeacon is better)
    if (o.description=='Libertalia') continue;

    // hide some of the location markers on the base map
    if (mapId == Object.keys(maps)[0]) {
      if (['City','Town'].includes(type) && area != mapId && o.ref_id!='07310FF5') continue; // duplicate city markers
      if (o.description == 'Military Base' && area != 'IWMWorld') continue; // duplicate tommies base
    }

    // hide interior doors (?)
    // if (type == 'Door' && !o.area) continue;

    let c = getLoc(feature);

    // align markers out of bounds to the edges
    let [left,top,right,bottom] = mapBounds;
    if (! (c.x>left && c.x<right && c.y>top && c.y<bottom )) {
      c.x = Math.min(left, Math.max(right, c.x));
      c.y = Math.min(top, Math.max(bottom, c.y));
    }

    cached_types[t.type] = {...cached_types[t.type], ...t};

    let marker = new maptalks.Marker(c, {
      properties: o,
      content: itemName(o),
      symbol: markerSymbol(o),
    }).addTo(markerLayer);

    const tooltip = new maptalks.ui.ToolTip( itemDescription(o) + ' in ' + itemLocation(o), {
      showTimeout: 50
    }).addTo(marker);

    marker.setInfoWindow({autoCloseOn: 'click'})
    .on('click', popupOnClick)
    .on('contextmenu', e=> {
      if (mouseMoved) return;
      let o = e.target.properties;
      toggleMarked(o.ref_id);
    })

    counters[t.group] = counters[t.group] || {};
    counters[t.group][t.type] = (counters[t.group][t.type] || 0) + 1;

    counters2[t.group] = counters2[t.group] || {};
    counters2[t.group][t.type] = counters2[t.group][t.type] || {};
    counters2[t.group][t.type][t.subtype] = (counters2[t.group][t.type][t.subtype] || 0) + 1;

    total += 1;
  }

  //console.log(cells);

  document.querySelector('#show-all').title = document.querySelector('#hide-all').title = plural(total,'marker');

  let ul = document.querySelector('#categories');
  let nodes = [];
  let groups = Object.keys(counters);

  for (group of groups.sort( (a,b)=> weights[b]-weights[a] || cmpAlphaNum(a,b)) ) {

    let header = document.createElement('div');
    header.innerHTML = capitalize(group);
    header.className = 'header';
    header.id = 'group-header-'+group;
    header.alt = group;
    header.onclick = toggleGroup;

    header.title = [plural(Object.values(counters[group]).reduce((a,c)=>a+c,0),'marker'),plural(Object.values(counters[group]).length,'category')].join(' in ');

    nodes.push(header);

    let div = document.createElement('div');
    div.className = 'group-categories';

    nodes.push(div);

    let items = [];
    for (const [type, count] of Object.entries(counters[group])) {
      items.push([type, count, type]);
    }

    for ([title, count, type] of items.sort(cmpAlphaNum)) {

      let t = cached_types[type];

      let li = document.createElement('div');
      li.className = 'item';
      li.classList.add('category-item');
      li.alt = t.type;
      li.onclick = toggleItem;

      let c0 = document.createElement('span');
      c0.className = 'icon';

      c0.classList.add('fa');
      c0.classList.add('fa-' + (t.group_fa||t.fa));
      // c0.style.color = t.bg; // color icons

      let c1 = document.createElement('span');
      c1.innerHTML = t.type;
      c1.className = 'title';

      let c2 = document.createElement('span');
      c2.innerHTML = count;
      c2.className = 'bubble';

      li.appendChild(c0);
      li.appendChild(c1);
      li.appendChild(c2);
      div.appendChild(li);

      let numTypes = Object.values(counters2[group][type]).length;

      li.title = numTypes > 1 ? [plural(count,'marker'), plural(numTypes,'type')].join(' of ') : plural(count,'marker');

      //console.log(counters[group][type]);
    }
  }

  ul.replaceChildren(...nodes);


  if (firstRun) {
    firstRun = false;
    // make it less cluttered maybe ?
    // document.querySelector('#group-header-items').click();
    saveSettings();
  }

  markItems();

  setTimeout(function() {
    if (enableAltitude && autoAltitude) {
      markerLayer.setOptions({enableAltitude: map.getPitch()!=0});
    }
  },500);

  if (debugParam) mapParam.markerName = debugParam;

  // settings.searchText = ''; // maybe don't open search results, you know

  // marker link
  if (name = mapParam.markerName) {
    jumpToLocation(name);
  } else {
    if (search = mapParam.search) {
      settings.searchText = search;
    }
    if (settings.searchText != '') {
      let searchInput = document.querySelector('#search-input');
      searchInput.value = settings.searchText;
      openSearch(settings.searchText);
    }
  }

  // build category selector
  let sel = document.querySelector('#track-category-panel > select');
  sel.innerHTML = '';
  let opt = document.createElement('option');
  opt.innerHTML = 'Select a Category';
  opt.value = '';
  sel.appendChild(opt);

  items = [];
  for (group of Object.keys(counters)) {
    for ([type, count] of Object.entries(counters[group])) {
      items.push([type, type]);
    }
  }

  for ([name,type] of items.sort(cmpAlphaNum)) {
    let opt = document.createElement('option');
    opt.value = type;
    opt.innerHTML = name;
    opt.title = name + ' (' + type + ')';
    sel.appendChild(opt);
  }

  mapParam = {}; // critical to reload map properly
}

function loadMap(id, cell) {
  map && map.remove();
  mapId = id;

  localData.mapId = mapId;
  settings = localData[mapId];

  saveSettings();

  createMap();

  let promises = ['./markers.json'].map(url=>fetch(url).then(r=>r.json()));
  Promise.all(promises).then(values => {
    markers = values[0];
    loadMarkers();
  }).catch(e=>{console.log(e);})

  return false;
}

function updateSearchResults(text) {
  for (marker of map.getLayer(layerName)._geoList) {
    marker.hide();
  }

  let extent = null;

  let div = document.querySelector('#search-items');
  let nodes = [];

  let result = fuzzySearch(text, 100, 0.25);

  for (r of result) {
    let o = r.item;

    o.marker.show();

    let c = o.marker.getCoordinates();
    extent = extent ? extent.combine(c) : new maptalks.Extent(c, c);

    let t = getType(o);

    let title = itemDescription(o) + ' in ' + itemLocation(o);

    let li = document.createElement('div');
    li.className = 'item';
    li.classList.add('search-item');
    li.title = title + ' [' + o.form_id + ']';
    li.alt = o.ref_id;
    li.onclick = clickSearchItem;

    let c0 = document.createElement('span');
    c0.className = 'icon';

    c0.classList.add('fa');
    c0.classList.add('fa-'+t.fa);

    let c1 = document.createElement('span');
    c1.innerHTML = title;
    c1.className = 'title';

    li.appendChild(c0);
    li.appendChild(c1);
    nodes.push(li);
  }

  div.replaceChildren(...nodes);

  // add secret copy search link
  let a = document.createElement('a');
  a.href = getBaseURL() + '#search/' + encodeURIComponent(text);
  a.onclick = function(e){ copyToClipboard(e.target.href); return false; };
  a.title = 'copy search url to clipboard';
  a.textContent = plural(result.length,'search result');
  document.querySelector('#search-count').replaceChildren(a);

  if (result.length>0) {
    map.setMaxZoom(5);
    // grow extent vertically so it's square
    if ((delta = extent.getWidth()-extent.getHeight())>0) {
      extent.ymin -= delta/2;
      extent.ymax += delta/2;
    }
    map.fitExtent(extent); 
    map.setMaxZoom(10);
  }
}

function jumpToMarker(id) {
  for (marker of map.getLayer('markers')._geoList) {
    let o = marker.properties;
    if (id == o.ref_id) {
      //map.animateTo({center: marker._coordinates});
      marker.show();
      popupOnClick({target: marker});
      marker.openInfoWindow();
      break;
    }
  }
}

const isVisible = function (ele, container) {
    const { bottom, height, top } = ele.getBoundingClientRect();
    const containerRect = container.getBoundingClientRect();
    return top <= containerRect.top ? containerRect.top - top <= height : bottom - containerRect.bottom <= height;
};

function selectSearchItem(step, id) {
  let elements = document.querySelectorAll('.search-item');
  let div = document.querySelector('#search-items');
  let count = elements.length;
  let container = document.querySelector('#left-panel');

  let current = null;
  [].forEach.call(elements, function(e, i) {
    if (e.classList.contains('selected')) current = i;
  });

  current = current==null ? 0 : ((current + count + step) % count);

  [].forEach.call(elements, function(e, i) {
    if (id == e.alt || (step && current == i)) {
      id = e.alt;
      e.classList.add('selected');
      //if (!isVisible(e, container)) e.scrollIntoView();
    } else {
      e.classList.remove('selected');
    }
  });

  jumpToMarker(id);
  setTimeout(function(){document.querySelector('#search-input').select()}, 100);
}

function clickSearchItem(e) {
  selectSearchItem(0, e.target.alt);
}

function openSearch(text) {
  setClass(document.querySelector('#search-result'), false, 'collapsed');
  setClass(document.querySelector('#search-close'), false, 'collapsed');
  setClass(document.querySelector('#categories-wrapper'), true, 'collapsed');

  if (text != settings.searchText || document.querySelectorAll('.search-item').length==0) {
    updateSearchResults(text);
  }

  selectSearchItem(1);

  settings.searchText = text;
  saveSettings();

  document.querySelector('#search-input').onkeydown = function(e) {
    switch (e.code) {
      case 'ArrowUp': selectSearchItem(-1); break;
      case 'ArrowDown': selectSearchItem(+1); break;
    }
  }
}

function closeSearch() {
  setClass(document.querySelector('#search-result'), true, 'collapsed');
  setClass(document.querySelector('#search-close'), true, 'collapsed');
  setClass(document.querySelector('#categories-wrapper'), false, 'collapsed');
  let searchInput = document.querySelector('#search-input');
  searchInput.value = '';
  searchInput.focus();
  settings.searchText = '';
  markItems();
  saveSettings();
  searchItemIndex = 0;
}

window.onload = function(event) {

  if (location.hash.length>1) {
    let param = decodeURIComponent(location.hash.slice(1));
    if (param.startsWith('search/')) {
      mapParam.search = param.split('/')[1];
    } else {
      mapParam.markerName = param;
      mapParam.mapId = Object.keys(maps)[0];
    }
  }

  try {
  // clear location hash
    history.pushState('', document.title, window.location.pathname + window.location.search);
  } catch(error) {
    console.log('handled error', error);
  }

  mapId = mapParam.mapId || localData.mapId || Object.keys(maps)[0];

  for (id of Object.keys(maps)) {
    if (!localData[id]) {
      localData[id] = {};
      firstRun = true;
    }
    localData[id].markedItems = localData[id].markedItems || {};
    localData[id].activeItems = localData[id].activeItems || {};
    localData[id].track = localData[id].track || {};
    localData[id].searchText = localData[id].searchText || '';
  }

  settings = localData[mapId];

  saveSettings();

  let bindings = {
    KeyA:['x',+1],KeyD:['x',-1],
    KeyW:['y',+1],KeyS:['y',-1],
    KeyQ:['b',+1],KeyE:['b',-1],
    KeyT:['z',+1],KeyG:['z',-1],
    KeyZ:['p',+1],KeyX:['p',-1],
  };

  function update(timestep) {
    let step = 20;
    let v = {};
    for (key of Object.keys(bindings)) {
      if (pressed[key]) {
        let [dir, step] = bindings[key];
        v[dir] = (v[dir]||0) + step;
      }
    }
    (v.x || v.y) && map.panBy([(v.x||0)*step, (v.y||0)*step], {duration: 1});
    v.b && map.setBearing(map.getBearing()+v.b*step/10);
    v.p && map.setPitch(map.getPitch()+v.p*step/10, {duration: 1});
    v.z && map.setZoom(map.getZoom()+v.z/16, {duration: 1});
    window.requestAnimationFrame(update);
  }

  window.addEventListener('keyup', (e) => {
    delete pressed[e.code];
  });

  window.addEventListener("keydown",function (e) {

    if (document.activeElement == document.querySelector('#search-input')) {
      pressed = {};
      return;
    }

    pressed[e.code] = true;

    switch (e.code) {
      case 'KeyR':
        if (map.getBearing()!=0) {
          map.animateTo({ bearing: 0 });
        } else {
          map.animateTo({ pitch: map.getPitch()==0 ? defaultPitch : 0 });
        }
      break;
      case 'KeyC': !e.ctrlKey && map.panTo(mapCenter); break;
      case 'Digit1': loadMap(Object.keys(maps)[0]); break;
      case 'Digit2': loadMap(Object.keys(maps)[1]); break;
      case 'Digit3': loadMap(Object.keys(maps)[2]); break;
      case 'Digit4': loadMap(Object.keys(maps)[3]); break;
      case 'Digit5': loadMap(Object.keys(maps)[4]); break;
      case 'Digit6': loadMap(Object.keys(maps)[5]); break;
    }
  });

  window.requestAnimationFrame(update);


  let promises = ['./types.json'].map(url=>fetch(url).then(r=>r.json()));
  Promise.all(promises).then(values => {
    types = values[0];
    loadMap(mapId);
  }).catch(e=>{console.log(e);})

  document.querySelector('#search-close').onclick = closeSearch;

  document.querySelector('#search-form').onkeydown = function(e) {
    if (e.code == 'Escape') {
      closeSearch();
    }
  }

  document.querySelector('#search-form').onsubmit = function(e) {
    e. preventDefault(); 
    let searchInput = document.querySelector('#search-input');
    let text = searchInput.value;
    if (text=='') {
      closeSearch();
    } else {
      openSearch(text);
    }
  }

  setClass(document.querySelector('#toggle-found'),settings.hideFound,'hidden');
  document.querySelector('#toggle-found').onclick = function(e) {
    settings.hideFound = toggleClass(e.target,'hidden');
    markItems();
    saveSettings();
  }

  document.querySelector('#toggle-left').onclick = (e) => {
    toggleClass(e.target, 'selected');
    toggleClass(document.querySelector('#left-sidebar'), 'mobile');

    setClass(document.querySelector('#toggle-right'), false, 'selected');
    setClass(document.querySelector('#right-sidebar'), false, 'mobile');
  }

  document.querySelector('#toggle-right').onclick = (e) => {
    toggleClass(e.target, 'selected');
    toggleClass(document.querySelector('#right-sidebar'), 'mobile');

    setClass(document.querySelector('#toggle-left'), false, 'selected');
    setClass(document.querySelector('#left-sidebar'), false, 'mobile');
  }

}

</script>

<!--a href="https://github.com/joric/maps/wiki/Fallout-London" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style-->
