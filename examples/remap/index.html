<!DOCTYPE html>
<html lang="en">
<head>
<base target="_top">
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">  

<title>Joric's Remap - Leaflet</title>
<link rel="shortcut icon" type="image/x-icon" href="data:," />

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.toolbar.js/0.1.0/Leaflet.Toolbar.min.css" integrity="sha512-GA6tz0ONkXAXGUnZU9M7mMkiOiXuXis56gRc73qvS+hXP0Sgb/mXihcqs6haKhes6mMeCPIdopIDixMwnnd+Iw==" crossorigin="anonymous" referrerpolicy="no-referrer" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.toolbar.js/0.1.0/Leaflet.Toolbar.min.js" integrity="sha512-5jHQLJ93JywT7NbjOuyHQzqLsTNYc7mjj0U5bBmsnrE1P9+4qqjKak0H+8jSlTzeNcbtDiTbV68pMQNTXbSTHQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-distortableimage@0.21.9/dist/leaflet.distortableimage.min.css">
<script src="https://cdn.jsdelivr.net/npm/leaflet-distortableimage@0.21.7/dist/vendor.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/leaflet-distortableimage@0.21.7/dist/leaflet.distortableimage.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-mouse-position@1.2.0/src/L.Control.MousePosition.min.css">
<script src="https://cdn.jsdelivr.net/npm/leaflet-mouse-position@1.2.0/src/L.Control.MousePosition.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/leaflet-search@4.0.0/dist/leaflet-search.src.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet-search@4.0.0/dist/leaflet-search.src.min.css">

<!--
  <script src="https://cdn.jsdelivr.net/npm/leaflet-distortableimage@0.21.9/dist/leaflet.distortableimage.min.js"></script>
  <script src="leaflet.distortableimage.js"></script>
  <link rel="stylesheet" href="leaflet.css" />
  <script src="leaflet.js"></script>
  <link rel="stylesheet" href="leaflet.toolbar.min.css"/>
  <script src="leaflet.toolbar.min.js"></script>
  <link rel="stylesheet" href="leaflet.distortableimage.css"/>
  <script src="vendor.js"></script>
  <script src="L.Control.MousePosition.js"></script>
-->

<style>
html, body {
  height: 100%;
  width: 100%;
  margin: 0;
}
#map {
  height: 100%;
  width:  100%;
}
#controls {
  position: absolute;
  margin: auto;
  left: 0;
  right: 0;
  bottom: 0;

  z-index: 1000;
  margin-bottom: 40px;
  
  text-align: center;
  width: 50%;
}
.slider {
  width: 100%;
}
</style>
</head>
<body>

<div id="map"></div>
<input id="file" type='file' hidden/>

<script>

let baseLayers = {};

baseLayers['CartoDB Voyager'] = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
  subdomains: 'abcd',
  maxZoom: 20
});

baseLayers['Esri World Imagery'] = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
});

baseLayers['Esri World Street Map'] = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Street_Map/MapServer/tile/{z}/{y}/{x}', {
  attribution: 'Tiles &copy; Esri &mdash; Source: Esri, DeLorme, NAVTEQ, USGS, Intermap, iPC, NRCAN, Esri Japan, METI, Esri China (Hong Kong), Esri (Thailand), TomTom, 2012'
});

baseLayers['OpenStreetMap Mapnik'] = L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
});

baseLayers['OSM Humanitarian'] = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors, Tiles style by <a href="https://www.hotosm.org/" target="_blank">Humanitarian OpenStreetMap Team</a> hosted by <a href="https://openstreetmap.fr/" target="_blank">OpenStreetMap France</a>'
});

baseLayers['Wikimedia'] = L.tileLayer('https://maps.wikimedia.org/osm-intl/{z}/{x}/{y}.png', {
  minZoom: 1,
  maxZoom: 18,
  attribution: '<a href="https://wikimediafoundation.org/wiki/Maps_Terms_of_Use">Wikimedia</a>'
});

baseLayers['Google Satellite'] = L.tileLayer('http://{s}.google.com/vt/lyrs=s&x={x}&y={y}&z={z}',{
  maxZoom: 20,
  subdomains:['mt0','mt1','mt2','mt3'],
  attribution: '<a href="https://cloud.google.com/maps-platform/terms?hl=es-419">Google Satellite</a>'
});

baseLayers['Google Streets'] = L.tileLayer('http://{s}.google.com/vt/lyrs=m&x={x}&y={y}&z={z}',{
  maxZoom: 20,
  subdomains:['mt0','mt1','mt2','mt3'],
  attribution: '<a href="https://cloud.google.com/maps-platform/terms?hl=es-419">Google Streets</a>'
});

baseLayers['Google Hybrid'] = L.tileLayer('http://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}',{
  maxZoom: 20,
  subdomains:['mt0','mt1','mt2','mt3'],
  attribution: '<a href="https://cloud.google.com/maps-platform/terms?hl=es-419">Google Hybrid</a>'
});

baseLayers['Google Terrain'] = L.tileLayer('http://{s}.google.com/vt/lyrs=p&x={x}&y={y}&z={z}',{
  maxZoom: 20,
  subdomains:['mt0','mt1','mt2','mt3'],
  attribution: '<a href="https://cloud.google.com/maps-platform/terms?hl=es-419">Google Terrain</a>'
});

baseLayers['Google Traffic'] = L.tileLayer('https://{s}.google.com/vt/lyrs=m@221097413,traffic&x={x}&y={y}&z={z}', {
  maxZoom: 20,
  minZoom: 2,
  subdomains: ['mt0', 'mt1', 'mt2', 'mt3'],
  attribution: '<a href="https://cloud.google.com/maps-platform/terms?hl=es-419">Google Traffic</a>'
});

baseLayers['Yandex MapJS'] = new L.TileLayer('https://core-renderer-tiles.maps.yandex.net/tiles?l=map&x={x}&y={y}&z={z}&lang=en', {
    reuseTiles: true, 
    updateWhenIdle: false,
    attribution: '<a href="https://yandex.ru/legal/maps_api/">Yandex Maps</a>'
});

baseLayers['Yandex Satellite'] = new L.TileLayer('https://core-sat.maps.yandex.net/tiles?l=map&x={x}&y={y}&z={z}&lang=en', {
    reuseTiles: true, 
    updateWhenIdle: false,
    attribution: '<a href="https://yandex.ru/legal/maps_api/">Yandex Satellite</a>'
});

let defaultLocalData = {
  'LondonWorld': {
    remap: {
      world: { size: 262144, center:[131072,131072] },
      image: 'https://joric.github.io/maps/examples/data/LondonWorld.jpg',
      markers: 'https://joric.github.io/maps/examples/data/geojson.markers.folon.json',
      corners: [{"lat":51.567501756256505,"lng":-0.1764177405505252},{"lat":51.567501756256505,"lng":0.06345199242442146},{"lat":51.41815601816625,"lng":-0.1764177405505252},{"lat":51.41815601816625,"lng":0.06345199242442146}],
      controlPoints: {

      /*
        '072FDB86': {
          title: 'London Eye',
          osm: { osm_id: 204068874 },
          coordinates: [51.5033416, -0.11967649999999999],
          warp: { inner: 1000, outer: 2000 },
        },

        "072FDC18": {
          "coordinates": [
            51.4956878,
            -0.25471169315339026
          ],
          "title": "The Tabard",
          "warp": { inner: 1000, outer: 2000 },
          "osm": {
            "name": "The Tabard",
            "osm_id": 209445869,
            "osm_type": "way",
            "coordinates": [
              51.4956878,
              -0.25471169315339026
            ],
          },
        },
        */

      },
      smoothing: 2,
      power: 5,
      activeLayers: {'Markers': true, 'Helpers': true},
      provider: Object.keys(baseLayers)[0],
      warped: true,
    }
  }
};

maps = {
  'LondonWorld' : { name: 'London', scale: 1, offset: {x:0, y:0},
    regions: {
      'WestminsterWorld' : { scale: 0.6, offset: {x:-104300, y:27900}, rotation: 0.57 },
      'CamdenWorld': { scale: 1, offset: {x:-79000, y:74000}, rotation: 0 },
      'IslingtonWorld': { scale: 0.95, offset: {x:-26600, y:66500}, rotation: 0.57 },
      'HackneyWorld': { scale: 0.95, offset: {x:19100, y:44000}, rotation: 0.78 },
      'BankofEnglandWorld': { scale: 1, offset: {x:-32000, y:35500} },
      'BromleyGladesWorld': { scale: 1, offset: {x:0, y:0} },
      'StPaulsWorld': { scale: 1, offset: {x:3000, y:0} },
      'CoventGardenWorldSpace': { scale: 1, offset: {x:1500, y:-2000} },
      'IWMWorld':{ scale: 1, offset: {x:0, y:0} },
    },
  },
}

let localDataName = 'joricsRemap';

let mapId = 'LondonWorld';
let settings = null;
let circleMarker = null;
let searchControl;

function setSelection(latlng, color='red') {
  removeSelection();
  if (latlng) {
    circleMarker = L.circleMarker(latlng, {radius: 10, color: color}).addTo(map);
  }
}

function removeSelection() {
  if (circleMarker) {
    map.removeLayer(circleMarker);
    delete circleMarker;
  }
}

function addHelpers(ref_id) {
  let cp = settings.remap.controlPoints[ref_id];
  if (cp && cp.warp && cp.warp.inner && cp.warp.outer) {
    let options = { fill: false, weight: 12, interactive: true, opacity: 0.25, ref_id: ref_id };
    L.circle(cp.coordinates, {...options, radius: cp.warp.outer, color: 'green', role: 'outer'}).addTo(helpersLayer).on('mousedown', startResize);
    L.circle(cp.coordinates, {...options, radius: cp.warp.inner, color: 'red', role: 'inner'}).addTo(helpersLayer).on('mousedown', startResize);
  }
}

function removeHelpers(ref_id) {
  getHelper(ref_id, 'inner') && map.removeLayer(getHelper(ref_id, 'inner'));
  getHelper(ref_id, 'outer') && map.removeLayer(getHelper(ref_id, 'outer'));
}

let circle;
let startGap;

const preventTextSelection = e=>e.preventDefault();

function startResize(e) {
  map.dragging.disable();
  document.addEventListener('selectstart', preventTextSelection );
  L.DomEvent.on(document, 'mousemove', resize);
  L.DomEvent.on(document, 'mouseup', stopResize);
  circle = e.target;
  let startPoint = map.mouseEventToLatLng(e.originalEvent);
  let startRadius = circle.getRadius();
  let startDistance = startPoint.distanceTo(circle.getLatLng());
  startGap = startRadius - startDistance;
  map.closePopup();
}

function getHelper(ref_id, role) {
  for (layer of getHelpers()) {
    if (layer.options.ref_id==ref_id && layer.options.role == role) {
      return layer;
    }
  }
}

function resize(e) {
  let newPoint = map.mouseEventToLatLng(e);
  let distance = newPoint.distanceTo(circle.getLatLng());
  let newRadius = distance + startGap;
  let ref_id = circle.options.ref_id;
  circle.setRadius( newRadius );

  let innerCircle = getHelper(ref_id, 'inner');
  let outerCircle = getHelper(ref_id, 'outer');

  if (circle==innerCircle) {
    if (newRadius > outerCircle.getRadius()) {
      outerCircle.setRadius(newRadius);
      settings.remap.controlPoints[ref_id].warp.outer = newRadius;
    }
    settings.remap.controlPoints[ref_id].warp.inner = newRadius;
  } else if (circle==outerCircle) {
    if (newRadius < innerCircle.getRadius()) {
      innerCircle.setRadius(newRadius);
      settings.remap.controlPoints[ref_id].warp.inner = newRadius;
    }
    settings.remap.controlPoints[ref_id].warp.outer = newRadius;
  }

  updateMarkers();
}

function stopResize(e) {
  L.DomEvent.off(document, 'mousemove', resize);
  L.DomEvent.off(document, 'mouseup', stopResize);
  map.dragging.enable();
  document.removeEventListener('selectstart', preventTextSelection); 
  updateHistory();
  saveSettings();
}


let localData = JSON.parse(localStorage.getItem(localDataName)) || defaultLocalData;
settings = localData[mapId];

let history = [];
let history_size = 100;
let history_pos = -1;

function updateHistory() {
  history_pos = (history_pos + 1) % history_size;
  //console.log('updating history', history_pos);
  history[history_pos] = JSON.stringify(settings);
}

function undo() {
  if (history_pos <= 0) return;
  history_pos -= 1;
  //console.log('undo', history_pos);
  settings = JSON.parse(history[history_pos]);
  updateMarkers();
  saveSettings();
}

function redo() {
  if (history_pos == history.length-1 || history_pos == history_size-1) return;
  history_pos += 1;
  //console.log('redo', history_pos);
  settings = JSON.parse(history[history_pos]);
  updateMarkers();
  saveSettings();
}

function saveSettings() {
  localStorage.setItem(localDataName, JSON.stringify(localData));
}

// we can have multiple areas in a single map, that one matches the name
let area = mapId;

let london = [51.505, -0.09];
let pos = london;
let zoom = 11;
let globalImage = null;

const map = L.map('map', {
  //zoomSnap: 0.1,
  //wheelDebounceTime: 100,
}).setView(pos, zoom);

let helpersLayer = L.layerGroup();
let markersLayer = L.layerGroup();
//let imagesLayer = L.distortableCollection(); // doesn't hide the image, only toolbar
let imagesLayer = L.layerGroup(); // doesn't show the image after hiding

settings.remap = settings.remap||{};
settings.remap.activeLayers = settings.remap.activeLayers||{};

let layers = {'Markers': markersLayer, 'Helpers': helpersLayer, 'Images':imagesLayer};

for (const [name,layer] of Object.entries(layers)) {
  if (settings.remap.activeLayers[name]==true) {
    map.addLayer(layer);
  }
}

function updateCRS(provider) {
  let center = map.getCenter();
  if (settings.remap.provider.match( /yandex/gi )) {
    map.options.crs = L.CRS.EPSG3395;
  } else {
    map.options.crs = L.CRS.EPSG3857;
  }
  map.setView(center);
  map._resetView(map.getCenter(), map.getZoom());
}

settings.remap.provider = settings.remap.provider || Object.keys(baseLayers)[0];

function baseLayerChange(name) {
  settings.remap.provider = name;
  updateCRS();
}

for (const [name, layer] of Object.entries(baseLayers)) {
  if (settings.remap.provider == name) {
    map.addLayer(layer);
    baseLayerChange(name);
  }
}

let layercontrol = L.control.layers(baseLayers, layers).addTo(map);

map.on('baselayerchange', function(e) {
  baseLayerChange(e.name);
});

// see https://github.com/publiclab/Leaflet.DistortableImage/issues/1323#issuecomment-2295487916
// distortableimage apparently doesn't reappear on adding, let's reload the image then
map.on('overlayadd', function(e) {
  settings.remap.activeLayers[e.name] = true;
  if (e.name == 'Images') {
    loadImages();
  }
  saveSettings();
});

map.on('overlayremove', function(e) {
  delete settings.remap.activeLayers[e.name];
  saveSettings();
});

map.on('moveend zoomend', function(e) {
  settings.center = [map.getCenter().lat, map.getCenter().lng]; // avoid circular refs here
  settings.zoom = map.getZoom();
  saveSettings();
});

if (settings.center && settings.zoom) {
  map.setView(settings.center, settings.zoom);
}

L.control.mousePosition().addTo(map);


let warpCaption = ()=>settings.remap.warped ? 'To Projected' : 'To Warped';

L.Control.MyButton = L.Control.extend({
    onAdd: function(map) {
        var btn = L.DomUtil.create('button', 'my-button');
        btn.innerHTML = warpCaption();
        L.DomEvent.on(btn, 'click', function() {
          settings.remap.warped = !settings.remap.warped;
          btn.innerHTML = warpCaption();
          updateMarkers();
        });
        return btn;
    }
});


L.control.myButton = function(opts) {
    return new L.Control.MyButton(opts);
}

L.control.myButton({ position: 'topright' }).addTo(map);

function PointFromArray(loc) {
  return {x:loc[0], y:loc[1]};
}

function bilinear(point, quadCorners, rectSize, rectCenter) {
  const normalizedPoint = point.add(rectCenter).divideBy(rectSize);
  normalizedPoint.y = 1 - normalizedPoint.y;
  const [topLeft, topRight, bottomLeft, bottomRight] = quadCorners;
  const interpolate = (a, b, factor) => a.add(b.subtract(a).multiplyBy(factor));
  const topEdge = interpolate(topLeft, topRight, normalizedPoint.x);
  const bottomEdge = interpolate(bottomLeft, bottomRight, normalizedPoint.x);
  return interpolate(topEdge, bottomEdge, normalizedPoint.y);
}

function processRegions(marker) {
  let [x, y] = marker.feature.geometry.coordinates;
  let area = marker.feature.properties.area;

  if (t = (maps[mapId].regions && maps[mapId].regions[area])) {
    x = x * t.scale + t.offset.x;
    y = y * t.scale + t.offset.y;
    if (t.rotation) {
      let cx = t.offset.x;
      let cy = t.offset.y;
      x = x - cx;
      y = y - cy;
      let tx = x * Math.cos(t.rotation) - y * Math.sin(t.rotation);
      let ty = x * Math.sin(t.rotation) + y * Math.cos(t.rotation);
      x = tx + cx;
      y = ty + cy;
    }
  }
  return {x: x, y: y};
}


function regions(point, area) {
  L.Point.prototype.rotate = function(angle) {
    let cos = Math.cos(angle);
    let sin = Math.sin(angle);
    let rotatedX = this.x * cos - this.y * sin;
    let rotatedY = this.x * sin + this.y * cos;
    return L.point(rotatedX, rotatedY);
  };

  if (t = (maps[mapId].regions && maps[mapId].regions[area])) {
    let center = L.point(t.offset);
    point = point.multiplyBy(t.scale).add(center);
    if (t.rotation) {
      point = point.subtract(center).rotate(t.rotation).add(center);
    }
  }
  return point;
}

function warp(point, controlPoints) {
  let totalWeight = 0;
  let weightedSum = L.point(0, 0);
  Object.values(controlPoints).forEach(controlPoint => {
    if (!controlPoint.innerRadius || !controlPoint.outerRadius) return
    let globalPoint = L.latLng([point.y, point.x])
    let globalOrigin = L.latLng([controlPoint.origin.y, controlPoint.origin.x])
    const distance = globalPoint.distanceTo(globalOrigin); 

    if (distance < controlPoint.outerRadius) {
      const weight = distance < controlPoint.innerRadius
        ? 1
        : 1 - (distance - controlPoint.innerRadius) / (controlPoint.outerRadius - controlPoint.innerRadius);
      totalWeight += weight;
      const relativePoint = point.subtract(controlPoint.origin);//.divideBy(distance / controlPoint.innerRadius);
      const adjustedPoint = controlPoint.position.add(relativePoint);
      weightedSum = weightedSum.add(adjustedPoint.multiplyBy(weight));
    }
  });
  return totalWeight > 0 ? weightedSum.divideBy(totalWeight) : point;
}

function globalWarp(point, controlPoints, smoothing = 0.00428, power = 5) {
  let totalWeight = 0;
  let weightedSum = L.point(0, 0);
  Object.values(controlPoints).forEach(controlPoint => {
    let globalPoint = L.latLng([point.y, point.x])
    let globalOrigin = L.latLng([controlPoint.origin.y, controlPoint.origin.x])
    const distance = Math.max(globalPoint.distanceTo(globalOrigin), smoothing);
    const weight = 1 / (distance ** power);
    totalWeight += weight;
    const relativePoint = point.subtract(controlPoint.origin);
    const adjustedPoint = controlPoint.position.add(relativePoint);
    weightedSum = weightedSum.add(adjustedPoint.multiplyBy(weight));
  });
  return totalWeight > 0 ? weightedSum.divideBy(totalWeight) : point;
}

function project(marker, controlPoints) {
  let point = L.point(marker.feature.geometry.coordinates);
  point = regions(point, marker.feature.properties.area);

  // do the bitmap remapping
  let worldCenter = L.point(settings.remap.world.center);
  let worldSize = settings.remap.world.size;
  let corners = settings.remap.corners.map(corner => L.point([corner.lng, corner.lat]));

  point = bilinear(point, corners, worldSize, worldCenter);

  // then warp to control points
  if (settings.remap.warped) {
    let p = controlPoints [ marker.feature.properties.ref_id ];
    if (p) {
      point = p.position;
    } else {
      point = warp(point, controlPoints);
      point = globalWarp(point, controlPoints, settings.remap.smoothing, settings.remap.power);
    }
  }

  return L.latLng([point.y, point.x]);
}

function getMarkerByRefId(ref_id) {
  for (marker of getMarkers()) {
    if (marker.feature.properties.ref_id == ref_id) return marker;
  }
  return null;
}

function getMarkerByTitle(title) {
  for (marker of getMarkers()) {
    if (marker.feature.properties.title == title) return marker;
  }
  return null;
}

function unbindMarker(ref_id) { 
  if (confirm('Are you sure you want to unbind this marker?')) {
    removeHelpers(ref_id);
    delete settings.remap.controlPoints [ ref_id ];
    updateMarkers();
    saveSettings();
    map.closePopup();
  }
}

function unwarpMarker(ref_id) {
  removeHelpers(ref_id);
  delete settings.remap.controlPoints[ref_id].warp;
  updateMarkers();
  saveSettings();
  map.closePopup();
}

function warpMarker(ref_id) {
  settings.remap.controlPoints[ref_id].warp = { inner: 200, outer: 400 };
  addHelpers(ref_id);
  updateMarkers();
  saveSettings();
  map.closePopup();
}

function setLocation(marker, latlng, data) {
  map.closePopup();
  if (!data || !latlng) {
    alert('Place not found');
    return
  }
  setSelection(latlng);
  map.flyTo(latlng);
  map.once('moveend', function() {
    if (confirm(['Set control point to this location?',
      `${data.display_name || data.name} (OSM ${data.osm_type}:${data.osm_id})`,
      'Click OK to continue, Cancel to fly back.'].join('\n\n'))) {
      updateControlPoint(marker, latlng, data);
      map.flyTo(latlng);
      saveSettings();
    } else {
      map.flyTo(marker.getLatLng());
    }
    removeSelection();
  });
}

function bindPopup(marker) {
  let o = marker.feature.properties;
  let name = o.title;

  let div = document.createElement('div');

  //let content = '';//'<pre>'+JSON.stringify(l.feature, null, 2)+'</pre>';
  let content = `<b>${o.title}</b>`;
  content += `<br/>${o.description}<br/><small>${o.area}</small>`;
  let latlng = marker.getLatLng();

  let strLL = String([latlng.lat, latlng.lng]);
  content += '<hr><a href="https://www.google.com/maps/search/'+encodeURIComponent(strLL)+'" target=_blank>'+strLL+'</a>';

  let cp = settings.remap.controlPoints[o.ref_id];
  let hasOSM = cp && cp.osm && cp.osm.osm_id && cp.osm.osm_type;  

  if (cp) {
    content += '<hr>';
    content += '<button id="unbind-marker-btn" onclick=unbindMarker("'+o.ref_id+'")>Unbind</button>';
    if (cp.warp) {
      content += ' <button id="unwarp-marker-btn" onclick=unwarpMarker("'+o.ref_id+'")>Unwarp</button>';
    } else {
      content += ' <button id="warp-marker-btn" onclick=warpMarker("'+o.ref_id+'")>Warp</button>';
    }
  }

  content += ' <span id="osm-link"></span><hr/>';

  content += '<div id="search-results-location"  style="margin-bottom: 8px;">';
  if (hasOSM) {
    content += '<button id="reset-location">'+(cp.osm.coordinates ? 'Reset Coordinates to Saved OSM' : 'Query Coordinates From OSM')+'</button>';
  }
  content += '</div>';

  content += '<form id="search-location-form"><input id="search-location-input"> <button id="search-location-btn" type="submit">Search</button></form>';

  div.innerHTML = content;

  let input = div.querySelector('#search-location-input');
  let text = marker.feature.properties.title;

  if (hasOSM) {
    text = cp.osm.name || text;

    let span = div.querySelector('#osm-link');
    let osm_url = 'https://www.openstreetmap.org/'+cp.osm.osm_type+'/'+cp.osm.osm_id;
    span.innerHTML = 'OSM: <a href="'+osm_url+'" target=_blank>'+cp.osm.osm_id+'</a>';

    let button = div.querySelector('#reset-location');
    if (cp.osm.coordinates) {
      let latlng = L.latLng(cp.osm.coordinates);
      setSelection(latlng, 'green');
      button.addEventListener('click', () => setLocation(marker, latlng, cp.osm));
    } else {
      setSelection(latlng);
      button.addEventListener('click', () => { 
        getOSM(cp.osm.osm_id, cp.osm.osm_type, (latlng, data) => { 
          if (data && latlng) { 
            setSelection(latlng); 
            setLocation(marker, latlng, data); 
          } 
        }); 
      });
    }
  } 

  input.value = text;
  setTimeout(()=>{input.select()},0);

  div.querySelector('#search-location-form').onsubmit = function() {
    let text = input.value;
    input.select();
    let oldLatLng = marker.getLatLng();
    searchOSM(text, function(latlng, data){
      let div = document.querySelector('#search-results-location');
      let url = 'https://www.google.com/maps/search/' + encodeURIComponent(text);

      if (data && latlng) {

        setSelection(latlng);

        let a = document.createElement('a');
        a.textContent = `${data.display_name}`;
        a.href = url;
        a.target = '_blank';

        let button = document.createElement('button');
        button.textContent = 'Use this location';

        button.onclick = function() {
          setLocation(marker, latlng, data);
        }

        let spacer = document.createElement('br');
        div.replaceChildren(a, spacer, button);

      } else {

        let a = document.createElement('a');
        a.textContent = 'Not found in OSM, try Google';
        a.href = url;
        a.target = '_blank';
        div.replaceChildren(a);
      }
    })

    return false; // critical to prevent reload on submit
  }

  return div;
}

function loadMarkers() {
  fetch(settings.remap.markers).then(r=>r.json()).then(data=>{

    let markers = L.geoJSON(data, {
      style: f => { color: f.properties.color },
      filter: f=> {

        let o = f.properties;
        let area = o.area;
        let type = o.description;
        let skip = (area != mapId && !(maps[mapId].regions && maps[mapId].regions[area]));

        if (!o.description || !o.title) skip= true;

        // hide some of the location markers on the base map
        if (mapId == Object.keys(maps)[0]) {
          if (['City','Town'].includes(type) && area != mapId && o.ref_id!='07310FF5') skip = true;
          if (type == 'Military Base' && area != 'IWMWorld') skip = true;
        }

        return !skip;
      },
      pointToLayer: function (feature, latlng) {
        let marker = L.marker(latlng, {draggable: true, opacity: 1});
        marker.on('drag', markerDragged)
        marker.on('dragend', markerDragEnd)
        marker.on('dragstart', markerDragStart)
        //marker.on('contextmenu', markerContextMenu)
        return marker;
      },
      onEachFeature: function(feature, marker) {
        marker.bindPopup(bindPopup)
        marker.on('popupclose', function() {
          removeSelection();
        })
        addHelpers(feature.properties.ref_id);
      }
    })

    markers.bindTooltip(marker => marker.feature.properties.title)

    markersLayer.addLayer(markers);

    updateMarkers();
    updateHistory(); // create a start point for undo

    searchControl = new L.Control.Search({
      layer: markers,
      hideMarkerOnCollapse: true,
      initial: false,
    }).addTo(map);
  })
}

function reloadImage() {
  if (globalImage) map.removeLayer(globalImage);
  delete globalImage;

  globalImage = L.distortableImageOverlay(settings.remap.image, {
    mode: 'lock',
    selected: true,
    //actions: [L.DragAction, L.ScaleAction, L.DistortAction, L.RotateAction, L.FreeRotateAction, L.LockAction, L.OpacityAction, L.BorderAction, L.ExportAction, L.DeleteAction, L.RestoreAction],
    actions: [L.ScaleAction, L.RotateAction, L.OpacityAction, L.RestoreAction, L.LockAction],
    corners: settings.remap.corners,
  }).on('update', imageUpdated).on('load', updateMarkers)
  imagesLayer.addLayer(globalImage);
}

function loadImages() {
  reloadImage();
}

function getMarkers() {
  let markers = markersLayer.getLayers(0)[0];
  return Object.values((markers && markers._layers)||{});
}

function getHelpers() {
  let markers = helpersLayer.getLayers(0);
  return Object.values(markers||{});
}

function updateMarkers() {

  let controlPoints = {};

  for (marker of getMarkers()) {
    let o = marker.feature.properties;
    let p = settings.remap.controlPoints[o.ref_id];
    let origin = project(marker, {});

    if (p) {
      let prop = {
        position: L.point(p.coordinates[1], p.coordinates[0]),
        origin: L.point([origin.lng, origin.lat]),
      }
      if (p.warp) {
        prop = {
          ...prop,
          innerRadius: p.warp.inner,
          outerRadius: p.warp.outer,
        };
      }
      controlPoints[o.ref_id] = prop;
    }
  }

  let cached_markers = {};

  for (marker of getMarkers()) {
    let o = marker.feature.properties;
    marker && marker.dragging && (settings.remap.warped ? marker.dragging.enable() : marker.dragging.disable());
    marker.setOpacity(settings.remap.controlPoints[o.ref_id] && settings.remap.warped ? 1 : .3);
    marker.setLatLng( project(marker, controlPoints ) );

    cached_markers [ o.ref_id ] = marker.getLatLng();
  }

  for (helper of getHelpers()) {
    let ref_id = helper.options.ref_id;
    let latlng = cached_markers[ ref_id ];
    if (latlng) {
      helper.setLatLng( latlng );
      let p = settings.remap.controlPoints[ ref_id ];
      if (p && p.warp) {
        if (helper.options.role == 'inner') helper.setRadius(p.warp.inner);
        if (helper.options.role == 'outer') helper.setRadius(p.warp.outer);
      }
    }
  }

}

function imageUpdated(e) {
  settings.remap.corners = e.target.getCorners();
  updateMarkers();
  saveSettings();
}

function updateControlPoint(marker, latlng, data) {
  //console.log('updating control point', marker, latlng, data);
  // create or update control point
  let o = marker.feature.properties;
  let cp = settings.remap.controlPoints;

  //if (!cp[o.ref_id]) return; //use bind button

  cp[o.ref_id] = cp[o.ref_id] || {};
  let p = cp[o.ref_id];

  p.coordinates =  [latlng.lat, latlng.lng];
  p.title =  p.title || o.title;

  if (data) {
    //console.log('setting point properties, osm_id is', data.osm_id);
    p.osm = p.osm || {};
    p.osm.osm_id = data.osm_id;
    p.osm.osm_type =  data.osm_type;
    p.osm.name = data.name;
    p.osm.coordinates = [latlng.lat, latlng.lng];
  }

  updateMarkers();
}

function markerDragStart() {
}

function markerDragEnd(e) {
  updateHistory();
  saveSettings();
}

function markerDragged(e) {
  let marker = e.target;
  updateControlPoint(marker, marker.getLatLng());
}

function markerContextMenu(e) {
  unbindMarker(e.target.feature.properties.title);
}

function copyToClipboard(text) {
  let input = document.body.appendChild(document.createElement("input"));
  input.value = text;
  input.focus();
  input.select();
  document.execCommand('copy');
  input.parentNode.removeChild(input);
  console.log(text + ' copied to clipboard');
}

let subAction = L.Toolbar2.Action.extend({
  initialize:function(map,myAction){this.map=map;this.myAction=myAction;L.Toolbar2.Action.prototype.initialize.call(this);},
  addHooks:function(){ this.myAction.disable(); }
});

new L.Toolbar2.Control({
    position: 'bottomleft',

    actions: [

      // share button
      L.Toolbar2.Action.extend({
        options: {
          toolbarIcon:{html: '&#x1F517;', tooltip: 'Share'},
          subToolbar: new L.Toolbar2({ 
            actions: [

              subAction.extend({
                options:{toolbarIcon:{html:'About the Map', tooltip: ''}},
                addHooks:function() {
                  let url = 'https://github.com/joric/maps/wiki/Fallout-London#remapping';
                  window.open(url, '_blank');
                  subAction.prototype.addHooks.call(this); // closes sub-action
                }
              }),


              subAction.extend({
                options:{toolbarIcon:{html:'&times;', tooltip: 'Close'}}
              }),

            ],
          })
        }
      }),

      // settings button
      L.Toolbar2.Action.extend({
        options: {
          toolbarIcon:{html: '&#x1F4C1;', tooltip: 'Files'},
          subToolbar: new L.Toolbar2({ 
            actions: [

              subAction.extend({
                options:{toolbarIcon:{html:'Load Settings', tooltip: 'Load Local Data'}},
                addHooks: function () {
                  loadLocalData();
                  subAction.prototype.addHooks.call(this);
                }
              }),

              subAction.extend({
                options:{toolbarIcon:{html:'Save Settings', tooltip: 'Save Local Data'}},
                addHooks:function() {
                  saveLocalData();
                  subAction.prototype.addHooks.call(this);
                }
              }),

              subAction.extend({
                options:{toolbarIcon:{html:'Reset Settings', tooltip: 'Reset Local Data'}},
                addHooks: function () { 
                  if (confirm('Are you sure you want to reset settings?')) {
                    resetLocalData();
                  }
                  subAction.prototype.addHooks.call(this);
                }
              }),

              subAction.extend({
                options:{toolbarIcon:{html:'Export Markers', tooltip: 'Export All Markers as GeoJSON'}},
                addHooks:function() {
                  exportMarkers();
                  subAction.prototype.addHooks.call(this);
                }
              }),


              subAction.extend({
                options:{toolbarIcon:{html:'&times;', tooltip: 'Close'}}
              }),
            ],
          })
        }
      }),
    ],
}).addTo(map);


function loadLocalDataFile() {
  var file = document.querySelector("#file").files[0];
  if (file) {
    var reader = new FileReader();
    reader.readAsText(file, "UTF-8");
    reader.onload = function (evt) {
      let data = evt.target.result;
      evt.target.value = null;
      try {
        localData = JSON.parse(data);
        settings = localData[mapId];
        console.log('New settings loaded.');
        saveSettings();

        location.reload();

      } catch(e) {
        console.log(e);
      }
    }
    reader.onerror = function (evt) {
      alert('error reading file');
    }
  }
}

function loadLocalData() {
  document.querySelector('#file').onchange = function(e) {
    loadLocalDataFile();
  }
  document.querySelector('#file').value = null;
  document.querySelector('#file').accept = '.json';
  document.querySelector('#file').click();
}

function saveLocalData() {
  let data = localStorage.getItem(localDataName);
  data = JSON.stringify(JSON.parse(data), null, 2);
  saveTextToFile(data, localDataName+'.json');
}

function resetLocalData() {
  localStorage.removeItem(localDataName);
  location.reload();
}

function exportControlPoints() {
  let data = settings.remap.controlPoints;
  let filename = 'controlPoints.'+mapId+'.json';
  saveTextToFile(JSON.stringify(data, null, 2), filename);
}

function saveTextToFile(data, filename) {
  if (window.showSaveFilePicker) {
    window.showSaveFilePicker({suggestedName: filename}).then(f=>f.createWritable()).then(f=>f.write(data).then(()=>f.close()));
  } else {
    let blob = new Blob([data], {type: "text/json"});
    if(navigator.msSaveOrOpenBlob) {
        navigator.msSaveOrOpenBlob(blob, filename);
    } else {
        var a = document.body.appendChild(document.createElement("a"));
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        a.remove();
    }
  }
}

function exportMarkers() {
  let data = {
    "type": "FeatureCollection",
    features: []
  };

  for (marker of getMarkers()) {
    let o = marker.feature.properties;
    let loc = marker.feature.geometry.coordinates;
    let f = structuredClone(marker.feature)
    let latlng = marker.getLatLng();
    f.geometry.coordinates[0] = latlng.lat;
    f.geometry.coordinates[1] = latlng.lng;
    f.geometry.coordinates[2] = loc[2] / 128 * 1.828; // 128 units = 1.828m

    let cp, p;
    if (cp = settings.remap.controlPoints[f.properties.ref_id]) {
      if (p = cp.osm) {
        f.properties.osm_id = p.osm_id;
        f.properties.osm_type = p.osm_type;
        f.properties.osm_name = p.name;
      }
    }
    data.features.push(f)
  }

  let filename = 'markers.' + mapId + '.json';
  saveTextToFile(JSON.stringify(data, null, 2), filename);
}

function getOSM(osm_id, osm_type, callback) {
  let url = `https://www.openstreetmap.org/api/0.6/${osm_type}/${osm_id}`+(osm_type!='node' ? '/full':'')+'.json';
  //console.log('fetching', url);
  fetch(url)
    .then(r => r.json())
    .then(json => {
      if (json) {
        //console.log(json);
        let data = {osm_id: osm_id, osm_type: osm_type, name: 'unknown', display_name: 'unknown'};
        let bounds = L.latLngBounds();
        for (e of Object.values(json.elements)) {
          if (e.tags && e.tags.name) {
            data.name = data.display_name = e.tags.name;
          }
          if (e.type=='node') {
            bounds.extend( L.latLng([e.lat, e.lon]) );
          }
        }
        let latlng = bounds.getCenter();
        console.log(latlng, data);
        return callback(latlng, data);
      } else {
        return callback();
      }
    });
  return true;
}

function searchOSM(text, callback) {
  let q = encodeURIComponent(text);
  const url = `https://nominatim.openstreetmap.org/search?q=${q}&format=json&limit=1&countrycodes=gb`;
  //console.log('fetching', url);
  fetch(url).then(r => r.json()).then(data => {
    //console.log(data);
    if (data.length > 0) {
      const latitude = data[0].lat;
      const longitude = data[0].lon;
      let latlng = L.latLng([latitude, longitude]);
      return callback(latlng, data[0]);
    } else {
      return callback();
    }
  })
  return true;
}

function importOldControlPoint(title, coord) {
  let marker;
  if (marker = getMarkerByTitle(title)) {
    updateControlPoint(marker, L.latLng(coord));
  }
}

onload = e => {

  // fetch global markers from server, merge to your control points
  fetch(localDataName+'.json').then(r=>r.json()).then(data=>{
    if (serverPoints = (data[mapId] && data[mapId].remap && data[mapId].remap.controlPoints)) {
      let before = Object.keys(settings.remap.controlPoints).length;
      settings.remap.controlPoints = {...serverPoints, ...settings.remap.controlPoints};
      let after = Object.keys(settings.remap.controlPoints).length;
      if (after>before) console.log(  (after-before) + ' control points imported from the server');
    }
  }).catch(e=>console.log('handled error', e));

  loadImages();
  loadMarkers();

  onkeydown = e => {
    if (e.ctrlKey) {
      switch (e.code) {
        case 'KeyZ': undo(); break;
        case 'KeyY': redo(); break;
        case 'KeyF':
          searchControl.expand(true);
          e.preventDefault();
          break;
      }
    }
  }


  let [sm,pw] = [document.querySelector('#smoothing'), document.querySelector('#power')];
  updateSlider(sm, settings.remap.smoothing);
  updateSlider(pw, settings.remap.power);

  function updateSliderTitle(c) {
    c.title = c.id + ': ' + c.value;
    updateMarkers();
  }

  function updateSlider(c, value) {
    c.value = value;
    updateSliderTitle(c);
  }

  function sliderEvent(e) {
    if (e.target.id=='smoothing') settings.remap.smoothing = e.target.value;
    if (e.target.id=='power') settings.remap.power = e.target.value;
    updateSliderTitle(e.target);
  }

  sm.oninput = sm.onchange = sliderEvent;
  pw.oninput = pw.onchange = sliderEvent;

}

</script>

<div id="controls">
  <div><input type="range" min="0.0" step="0.01" max="25" value="0" class="slider" id="power"></div>
  <div><input type="range" min="0.0" step="1" max="10000" value="0" class="slider" id="smoothing"></div>
</div>

</body>
</html>
